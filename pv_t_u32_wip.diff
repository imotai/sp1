Commit ID: a94386b0f66fa11adef0eb4d4038a8a4d89844c6
Change ID: nuqrywxqurnsvswuknxwrlrknkprtwsp
Author   : Tej Qu Nair <tej.q.nair@gmail.com> (2025-06-18 21:54:43)
Committer: Tej Qu Nair <tej.q.nair@gmail.com> (2025-06-18 22:02:27)

    (no description set)

diff --git a/crates/core/executor/src/events/instr.rs b/crates/core/executor/src/events/instr.rs
index 48f69ce8e9..fb1fd13ea7 100644
--- a/crates/core/executor/src/events/instr.rs
+++ b/crates/core/executor/src/events/instr.rs
@@ -13,7 +13,7 @@
     /// The clock cycle.
     pub clk: u32,
     /// The program counter.
-    pub pc_rel: u64,
+    pub pc_rel: u32,
     /// The opcode.
     pub opcode: Opcode,
     /// The first operand value.
@@ -32,7 +32,7 @@
     #[allow(clippy::too_many_arguments)]
     pub fn new(
         clk: u32,
-        pc_rel: u64,
+        pc_rel: u32,
         opcode: Opcode,
         a: u64,
         b: u64,
@@ -54,7 +54,7 @@
     /// The clk.
     pub clk: u32,
     /// The program counter.
-    pub pc_rel: u64,
+    pub pc_rel: u32,
     /// The opcode.
     pub opcode: Opcode,
     /// The first operand value.
@@ -76,7 +76,7 @@
     pub fn new(
         shard: u32,
         clk: u32,
-        pc_rel: u64,
+        pc_rel: u32,
         opcode: Opcode,
         a: u64,
         b: u64,
@@ -97,9 +97,9 @@
     /// The clock cycle.
     pub clk: u32,
     /// The program counter.
-    pub pc_rel: u64,
+    pub pc_rel: u32,
     /// The next program counter.
-    pub next_pc_rel: u64,
+    pub next_pc_rel: u32,
     /// The opcode.
     pub opcode: Opcode,
     /// The first operand value.
@@ -118,8 +118,8 @@
     #[allow(clippy::too_many_arguments)]
     pub fn new(
         clk: u32,
-        pc_rel: u64,
-        next_pc_rel: u64,
+        pc_rel: u32,
+        next_pc_rel: u32,
         opcode: Opcode,
         a: u64,
         b: u64,
@@ -139,9 +139,9 @@
     /// The clock cycle.
     pub clk: u32,
     /// The program counter.
-    pub pc_rel: u64,
+    pub pc_rel: u32,
     /// The next program counter.
-    pub next_pc_rel: u64,
+    pub next_pc_rel: u32,
     /// The opcode.
     pub opcode: Opcode,
     /// The first operand value.
@@ -160,8 +160,8 @@
     #[allow(clippy::too_many_arguments)]
     pub fn new(
         clk: u32,
-        pc_rel: u64,
-        next_pc_rel: u64,
+        pc_rel: u32,
+        next_pc_rel: u32,
         opcode: Opcode,
         a: u64,
         b: u64,
@@ -180,7 +180,7 @@
     /// The clock cycle.
     pub clk: u32,
     /// The program counter.
-    pub pc_rel: u64,
+    pub pc_rel: u32,
     /// The opcode.
     pub opcode: Opcode,
     /// The first operand value.
@@ -199,7 +199,7 @@
     #[allow(clippy::too_many_arguments)]
     pub fn new(
         clk: u32,
-        pc_rel: u64,
+        pc_rel: u32,
         opcode: Opcode,
         a: u64,
         b: u64,
diff --git a/crates/core/executor/src/events/syscall.rs b/crates/core/executor/src/events/syscall.rs
index e8fce9b829..abb03eb83f 100644
--- a/crates/core/executor/src/events/syscall.rs
+++ b/crates/core/executor/src/events/syscall.rs
@@ -10,9 +10,9 @@
 #[repr(C)]
 pub struct SyscallEvent {
     /// The program counter.
-    pub pc_rel: u64,
+    pub pc_rel: u32,
     /// The next program counter.
-    pub next_pc_rel: u64,
+    pub next_pc_rel: u32,
     /// The shard number.
     pub shard: u32,
     /// The clock cycle.
diff --git a/crates/core/executor/src/executor.rs b/crates/core/executor/src/executor.rs
index 2668597ffd..d750c6c058 100644
--- a/crates/core/executor/src/executor.rs
+++ b/crates/core/executor/src/executor.rs
@@ -45,7 +45,7 @@
 pub const PC_INC: u32 = 4;
 /// The executor uses this PC to determine if the program has halted.
 /// As a PC, it is invalid since it is not a multiple of [`PC_INC`].
-pub const HALT_PC: u64 = 1;
+pub const HALT_PC: u32 = 1;
 
 /// The maximum number of instructions in a program.
 pub const MAX_PROGRAM_SIZE: usize = 1 << 22;
@@ -396,7 +396,7 @@
         Self {
             record: Box::new(record),
             records: vec![],
-            state: ExecutionState::new(program.pc_start_rel_u64()),
+            state: ExecutionState::new(program.pc_start_rel_u32()),
             program,
             program_len,
             memory_accesses: MemoryAccessRecord::default(),
@@ -1110,7 +1110,7 @@
     fn emit_events(
         &mut self,
         clk: u32,
-        next_pc_rel: u64,
+        next_pc_rel: u32,
         instruction: &Instruction,
         syscall_code: SyscallCode,
         a: u64,
@@ -1305,7 +1305,7 @@
         c: u64,
         record: MemoryAccessRecord,
         op_a_0: bool,
-        next_pc_rel: u64,
+        next_pc_rel: u32,
     ) {
         let event = BranchEvent {
             clk: self.state.clk,
@@ -1332,7 +1332,7 @@
         c: u64,
         record: MemoryAccessRecord,
         op_a_0: bool,
-        next_pc_rel: u64,
+        next_pc_rel: u32,
     ) {
         let event = JumpEvent {
             clk: self.state.clk,
@@ -1359,7 +1359,7 @@
         c: u64,
         record: MemoryAccessRecord,
         op_a_0: bool,
-        next_pc_rel: u64,
+        next_pc_rel: u32,
     ) {
         let event = JumpEvent {
             clk: self.state.clk,
@@ -1402,7 +1402,7 @@
         arg1: u64,
         arg2: u64,
         op_a_0: bool,
-        next_pc_rel: u64,
+        next_pc_rel: u32,
         exit_code: u32,
     ) -> SyscallEvent {
         // should_send: if the syscall is usually sent and it is not manually set as internal.
@@ -1433,7 +1433,7 @@
         arg2: u64,
         record: MemoryAccessRecord,
         op_a_0: bool,
-        next_pc_rel: u64,
+        next_pc_rel: u32,
         exit_code: u32,
     ) {
         let syscall_event =
@@ -1562,7 +1562,7 @@
         } else if instruction.is_auipc_instruction() {
             let (rd, imm) = instruction.u_type();
             (b, c) = (imm, imm);
-            a = self.state.pc_rel.wrapping_add(self.program.pc_base).wrapping_add(b);
+            a = (self.state.pc_rel as u64).wrapping_add(self.program.pc_base).wrapping_add(b);
             self.rw_cpu::<E>(rd, a);
         } else if instruction.is_ecall_instruction() {
             (a, b, c, clk, next_pc_rel, syscall, exit_code) = self.execute_ecall::<E>()?;
@@ -1800,8 +1800,8 @@
     fn execute_branch<E: ExecutorConfig>(
         &mut self,
         instruction: &Instruction,
-        mut next_pc_rel: u64,
-    ) -> (u64, u64, u64, u64) {
+        mut next_pc_rel: u32,
+    ) -> (u64, u64, u64, u32) {
         let (a, b, c) = self.branch_rr::<E>(instruction);
         let branch = match instruction.opcode {
             Opcode::BEQ => a == b,
@@ -1815,7 +1815,7 @@
             }
         };
         if branch {
-            next_pc_rel = self.state.pc_rel.wrapping_add(c);
+            next_pc_rel = self.state.pc_rel.wrapping_add(c as u32);
         }
         (a, b, c, next_pc_rel)
     }
@@ -1824,7 +1824,7 @@
     #[allow(clippy::type_complexity)]
     fn execute_ecall<E: ExecutorConfig>(
         &mut self,
-    ) -> Result<(u64, u64, u64, u32, u64, SyscallCode, u32), ExecutionError> {
+    ) -> Result<(u64, u64, u64, u32, u32, SyscallCode, u32), ExecutionError> {
         // We peek at register x5 to get the syscall id. The reason we don't `self.rr` this
         // register is that we write to it later.
         let t0 = Register::X5;
@@ -1921,14 +1921,14 @@
     fn execute_jump<E: ExecutorConfig>(
         &mut self,
         instruction: &Instruction,
-    ) -> (u64, u64, u64, u64) {
+    ) -> (u64, u64, u64, u32) {
         let (a, b, c, next_pc_rel) = match instruction.opcode {
             Opcode::JAL => {
                 let (rd, imm) = instruction.j_type();
                 let imm_se = sign_extend_imm(imm, 21);
-                let a = self.program.pc_base.wrapping_add(self.state.pc_rel).wrapping_add(4);
+                let a = self.program.pc_base.wrapping_add(self.state.pc_rel as u64).wrapping_add(4);
                 self.rw_cpu::<E>(rd, a);
-                let next_pc_rel = ((self.state.pc_rel as i64).wrapping_add(imm_se)) as u64;
+                let next_pc_rel = ((self.state.pc_rel as i64).wrapping_add(imm_se)) as u32;
                 let b = imm_se as u64;
                 let c = 0;
                 (a, b, c, next_pc_rel)
@@ -1937,10 +1937,10 @@
                 let (rd, rs1, c) = instruction.i_type();
                 let imm_se = sign_extend_imm(c, 12);
                 let b = self.rr_cpu::<E>(rs1, MemoryAccessPosition::B);
-                let a = self.program.pc_base.wrapping_add(self.state.pc_rel).wrapping_add(4);
+                let a = self.program.pc_base.wrapping_add(self.state.pc_rel as u64).wrapping_add(4);
                 // Calculate next PC: (rs1 + imm) & ~1
                 let next_pc_rel = (((b as i64).wrapping_add(imm_se) as u64) & !1_u64)
-                    .wrapping_sub(self.program.pc_base);
+                    .wrapping_sub(self.program.pc_base) as u32;
                 self.rw_cpu::<E>(rd, a);
 
                 (a, b, c, next_pc_rel)
@@ -2028,7 +2028,7 @@
         }
 
         let done = self.state.pc_rel == HALT_PC
-            || self.state.pc_rel >= (self.program.instructions.len() * 4) as u64;
+            || self.state.pc_rel as usize >= self.program.instructions.len() * 4;
         if done && E::UNCONSTRAINED {
             tracing::error!("program ended in unconstrained mode at clk {}", self.state.global_clk);
             return Err(ExecutionError::EndInUnconstrained());
@@ -2101,7 +2101,7 @@
     pub fn execute_state(
         &mut self,
         emit_global_memory_events: bool,
-    ) -> Result<(ExecutionState, PublicValues<u64, u64, u64>, bool), ExecutionError> {
+    ) -> Result<(ExecutionState, PublicValues<u64, u64, u32>, bool), ExecutionError> {
         self.memory_checkpoint.clear();
         self.emit_global_memory_events = emit_global_memory_events;
 
@@ -2219,7 +2219,7 @@
             self.execute_instruction::<Unconstrained>(&instruction)?;
 
             done = self.state.pc_rel == HALT_PC
-                || self.state.pc_rel >= (self.program.instructions.len() * 4) as u64;
+                || self.state.pc_rel as usize >= self.program.instructions.len() * 4;
         }
 
         Ok(())
@@ -2324,12 +2324,12 @@
             record.public_values = public_values;
             record.public_values.committed_value_digest = public_values.committed_value_digest;
             record.public_values.deferred_proofs_digest = public_values.deferred_proofs_digest;
-            record.public_values.execution_shard = start_shard.get() as u64 + i as u64;
+            record.public_values.execution_shard = start_shard.get() as u32 + i as u32;
             if record.contains_cpu() {
                 record.public_values.pc_start_rel = record.pc_start_rel.unwrap();
                 record.public_values.next_pc_rel = record.next_pc_rel;
-                record.public_values.exit_code = record.exit_code as u64;
-                record.public_values.last_timestamp = record.last_timestamp as u64;
+                record.public_values.exit_code = record.exit_code as u32;
+                record.public_values.last_timestamp = record.last_timestamp as u32;
                 last_next_pc = record.public_values.next_pc_rel;
                 last_exit_code = record.public_values.exit_code;
             } else {
@@ -2569,7 +2569,10 @@
         #[cfg(feature = "profiling")]
         if let Some((ref mut profiler, _)) = self.profiler {
             if !E::UNCONSTRAINED {
-                profiler.record(self.state.global_clk, self.state.pc_rel);
+                profiler.record(
+                    self.state.global_clk,
+                    (self.state.pc_rel as u64).wrapping_add(self.program.pc_base),
+                );
             }
         }
 
diff --git a/crates/core/executor/src/program.rs b/crates/core/executor/src/program.rs
index 6fb98b1e51..7f8591e17e 100644
--- a/crates/core/executor/src/program.rs
+++ b/crates/core/executor/src/program.rs
@@ -98,22 +98,26 @@
 
     #[must_use]
     /// Fetch the instruction at the given program counter.
-    pub fn fetch(&self, pc_rel: u64) -> &Instruction {
+    pub fn fetch(&self, pc_rel: u32) -> &Instruction {
         let idx = (pc_rel / 4) as usize;
         &self.instructions[idx]
     }
 
     /// Returns `self.pc_start - self.pc_base`, that is, the relative `pc_start`.
     #[must_use]
-    pub fn pc_start_rel_u64(&self) -> u64 {
-        self.pc_start_abs.checked_sub(self.pc_base).expect("expected pc_base <= pc_start")
+    pub fn pc_start_rel_u32(&self) -> u32 {
+        self.pc_start_abs
+            .checked_sub(self.pc_base)
+            .expect("expected pc_base <= pc_start")
+            .try_into()
+            .expect("pc_start_rel should fit in `u32")
     }
 }
 
 impl<F: PrimeField32> MachineProgram<F> for Program {
     fn pc_start_rel(&self) -> F {
-        let pc_start_rel = self.pc_start_rel_u64();
-        assert!(pc_start_rel < F::ORDER_U64);
+        let pc_start_rel = self.pc_start_rel_u32();
+        assert!(pc_start_rel < F::ORDER_U32);
         // Casting to u32 and truncating is okay, since F: PrimeField32 means it fits.
         F::from_wrapped_u32(pc_start_rel as u32)
     }
diff --git a/crates/core/executor/src/record.rs b/crates/core/executor/src/record.rs
index bc97da136d..02d438a7e2 100644
--- a/crates/core/executor/src/record.rs
+++ b/crates/core/executor/src/record.rs
@@ -105,13 +105,13 @@
     /// A trace of all the global interaction events.
     pub global_interaction_events: Vec<GlobalInteractionEvent>,
     /// The global culmulative sum.
-    pub global_cumulative_sum: Arc<Mutex<SepticDigest<u64>>>,
+    pub global_cumulative_sum: Arc<Mutex<SepticDigest<u32>>>,
     /// The global interaction event count.
     pub global_interaction_event_count: u32,
     /// Memory records with `prev_shard` different from `shard`.
     pub shard_bump_memory_events: Vec<(MemoryRecordEnum, u64)>,
     /// The public values.
-    pub public_values: PublicValues<u64, u64, u64>,
+    pub public_values: PublicValues<u64, u64, u32>,
     /// The next nonce to use for a new lookup.
     pub next_nonce: u64,
     /// The shape of the proof.
@@ -123,9 +123,9 @@
     /// The final timestamp of the shard.
     pub last_timestamp: u32,
     /// The start program counter.
-    pub pc_start_rel: Option<u64>,
+    pub pc_start_rel: Option<u32>,
     /// The final program counter.
-    pub next_pc_rel: u64,
+    pub next_pc_rel: u32,
     /// The exit code.
     pub exit_code: u32,
 }
diff --git a/crates/core/executor/src/state.rs b/crates/core/executor/src/state.rs
index de2354cece..bb184e822e 100644
--- a/crates/core/executor/src/state.rs
+++ b/crates/core/executor/src/state.rs
@@ -20,7 +20,7 @@
 #[repr(C)]
 pub struct ExecutionState {
     /// The program counter minus the program's `pc_base`.
-    pub pc_rel: u64,
+    pub pc_rel: u32,
 
     /// The shard clock keeps track of how many shards have been executed.
     pub current_shard: Shard,
@@ -65,7 +65,7 @@
 impl ExecutionState {
     #[must_use]
     /// Create a new [`ExecutionState`].
-    pub fn new(pc_start_rel: u64) -> Self {
+    pub fn new(pc_start_rel: u32) -> Self {
         Self {
             global_clk: 0,
             // Start at shard 1 since shard 0 is reserved for memory initialization.
@@ -93,7 +93,7 @@
     /// The original `clk` value at the fork point.
     pub clk: u32,
     /// The original `pc` value at the fork point.
-    pub pc: u64,
+    pub pc_rel: u32,
     /// All memory changes since the fork point.
     pub memory_diff: Memory<Option<MemoryEntry>>,
 }
diff --git a/crates/core/executor/src/syscalls/context.rs b/crates/core/executor/src/syscalls/context.rs
index f7b6bcb234..7d50542e64 100644
--- a/crates/core/executor/src/syscalls/context.rs
+++ b/crates/core/executor/src/syscalls/context.rs
@@ -21,7 +21,7 @@
     /// The clock cycle.
     pub clk: u32,
     /// The next program counter.
-    pub next_pc_rel: u64,
+    pub next_pc_rel: u32,
     /// The exit code.
     pub exit_code: u32,
     /// The runtime.
@@ -195,7 +195,7 @@
     }
 
     /// Set the next program counter.
-    pub fn set_next_pc(&mut self, next_pc_rel: u64) {
+    pub fn set_next_pc(&mut self, next_pc_rel: u32) {
         self.next_pc_rel = next_pc_rel;
     }
 
diff --git a/crates/core/executor/src/syscalls/unconstrained.rs b/crates/core/executor/src/syscalls/unconstrained.rs
index b63957cab0..58a0cbacda 100644
--- a/crates/core/executor/src/syscalls/unconstrained.rs
+++ b/crates/core/executor/src/syscalls/unconstrained.rs
@@ -21,7 +21,7 @@
     ctx.rt.unconstrained_state = Box::new(ForkState {
         global_clk: ctx.rt.state.global_clk,
         clk: ctx.rt.state.clk,
-        pc: ctx.rt.state.pc_rel,
+        pc_rel: ctx.rt.state.pc_rel,
         memory_diff: Memory::default(),
     });
 
@@ -35,7 +35,7 @@
     // Update the state of the runtime to match the saved state.
     ctx.rt.state.global_clk = ctx.rt.unconstrained_state.global_clk;
     ctx.rt.state.clk = ctx.rt.unconstrained_state.clk;
-    ctx.rt.state.pc_rel = ctx.rt.unconstrained_state.pc;
+    ctx.rt.state.pc_rel = ctx.rt.unconstrained_state.pc_rel;
     ctx.next_pc_rel = ctx.rt.state.pc_rel.wrapping_add(4);
 
     let memory_diff = std::mem::take(&mut ctx.rt.unconstrained_state.memory_diff);
diff --git a/crates/core/machine/src/adapter/state.rs b/crates/core/machine/src/adapter/state.rs
index 7591b61904..d903e613a9 100644
--- a/crates/core/machine/src/adapter/state.rs
+++ b/crates/core/machine/src/adapter/state.rs
@@ -35,7 +35,7 @@
         blu_events: &mut impl ByteRecord,
         shard: u32,
         clk: u32,
-        pc_rel: u64,
+        pc_rel: u32,
     ) {
         let clk_high_limb = (clk >> 14) as u16;
         let clk_low_limb = (clk & ((1 << 14) - 1)) as u16;
diff --git a/crates/core/machine/src/executor.rs b/crates/core/machine/src/executor.rs
index c88956bf92..7e2d40392f 100644
--- a/crates/core/machine/src/executor.rs
+++ b/crates/core/machine/src/executor.rs
@@ -85,7 +85,7 @@
     done: bool,
     program: Arc<Program>,
     record_gen_sync: Arc<TurnBasedSync>,
-    state: Arc<Mutex<PublicValues<u64, u64, u64>>>,
+    state: Arc<Mutex<PublicValues<u64, u64, u32>>>,
     deferred: Arc<Mutex<ExecutionRecord>>,
     record_tx: mpsc::Sender<ExecutionRecord>,
     abort_handle: AbortHandle,
diff --git a/crates/core/machine/src/utils/mod.rs b/crates/core/machine/src/utils/mod.rs
index 6003269595..b0bf9e81cc 100644
--- a/crates/core/machine/src/utils/mod.rs
+++ b/crates/core/machine/src/utils/mod.rs
@@ -160,19 +160,19 @@
 /// Extension methods for `Instruction` that are relevant only for this crate.
 pub(crate) trait InstructionExt {
     /// Preprocess an instruction for use in arithmetization.
-    fn preprocess<F: PrimeField64>(self, pc_base: u64, pc_rel: u64) -> Self;
+    fn preprocess<F: PrimeField64>(self, pc_base: u64, pc_rel: u32) -> Self;
     /// Preprocess a branch (conditional jump) instruction for use in arithmetization.
-    fn preprocess_branch<F: PrimeField64>(self, pc_rel: u64) -> Self;
+    fn preprocess_branch<F: PrimeField64>(self, pc_rel: u32) -> Self;
     /// Preprocess a `JAL` instruction for use in arithmetization.
-    fn preprocess_jal<F: PrimeField64>(self, pc_base: u64, pc_rel: u64) -> Self;
+    fn preprocess_jal<F: PrimeField64>(self, pc_base: u64, pc_rel: u32) -> Self;
     /// Preprocess a `JALR` instruction for use in arithmetization.
-    fn preprocess_jalr(self, pc_base: u64, pc_rel: u64) -> Self;
+    fn preprocess_jalr(self, pc_base: u64, pc_rel: u32) -> Self;
     /// Preprocess an `AUIPC` instruction for use in arithmetization.
-    fn preprocess_auipc(self, pc_base: u64, pc_rel: u64) -> Self;
+    fn preprocess_auipc(self, pc_base: u64, pc_rel: u32) -> Self;
 }
 
 impl InstructionExt for Instruction {
-    fn preprocess<F: PrimeField64>(self, pc_base: u64, pc_rel: u64) -> Self {
+    fn preprocess<F: PrimeField64>(self, pc_base: u64, pc_rel: u32) -> Self {
         if self.is_branch_instruction() {
             self.preprocess_branch::<F>(pc_rel)
         } else if self.is_jal_instruction() {
@@ -186,7 +186,7 @@
         }
     }
 
-    fn preprocess_branch<F: PrimeField64>(mut self, pc_rel: u64) -> Self {
+    fn preprocess_branch<F: PrimeField64>(mut self, pc_rel: u32) -> Self {
         // c is first imm, then pc_rel + imm.
         self.op_c = pc_rel.wrapping_add(self.op_c);
         // Check that the resulting term of "type PC" fits.
@@ -194,7 +194,7 @@
         self
     }
 
-    fn preprocess_jal<F: PrimeField64>(mut self, pc_base: u64, pc_rel: u64) -> Instruction {
+    fn preprocess_jal<F: PrimeField64>(mut self, pc_base: u64, pc_rel: u32) -> Instruction {
         // rd <- pc + 4; pc <- pc + imm
         // (a, b, c) is first (rd, imm, _) and then (rd, pc_rel + imm, pc + 4).
         // We have to translate the relative pc to an absolute pc before storing it
@@ -209,7 +209,7 @@
         self
     }
 
-    fn preprocess_jalr(mut self, pc_base: u64, pc_rel: u64) -> Instruction {
+    fn preprocess_jalr(mut self, pc_base: u64, pc_rel: u32) -> Instruction {
         // rd <- pc + 4; pc <- rs1 + imm
         // (a, b, c) is
         // - first (rd, rs1, imm)
@@ -223,7 +223,7 @@
         self
     }
 
-    fn preprocess_auipc(mut self, pc_base: u64, pc_rel: u64) -> Instruction {
+    fn preprocess_auipc(mut self, pc_base: u64, pc_rel: u32) -> Instruction {
         // rd <- pc + imm
         let pc_abs = pc_rel.wrapping_add(pc_base);
         self.op_b = pc_abs.wrapping_add(self.op_b);
diff --git a/crates/core/machine/src/utils/prove.rs b/crates/core/machine/src/utils/prove.rs
index 56db51b8a2..c31d47cab4 100644
--- a/crates/core/machine/src/utils/prove.rs
+++ b/crates/core/machine/src/utils/prove.rs
@@ -65,7 +65,7 @@
     record_gen_sync: Arc<TurnBasedSync>,
     checkpoints_rx: Arc<Mutex<Receiver<(usize, File, bool, u64)>>>,
     records_tx: Sender<ExecutionRecord>,
-    state: Arc<Mutex<PublicValues<u64, u64, u64>>>,
+    state: Arc<Mutex<PublicValues<u64, u64, u32>>>,
     deferred: Arc<Mutex<ExecutionRecord>>,
     report_aggregate: Arc<Mutex<ExecutionReport>>,
     opts: SP1CoreOpts,
diff --git a/crates/stark/src/air/public_values.rs b/crates/stark/src/air/public_values.rs
index ca7ead419d..567cf1a8a7 100644
--- a/crates/stark/src/air/public_values.rs
+++ b/crates/stark/src/air/public_values.rs
@@ -84,7 +84,7 @@
     pub empty: [T; 7],
 }
 
-impl PublicValues<u64, u64, u64> {
+impl PublicValues<u64, u64, u32> {
     /// Convert the public values into a vector of field elements.  This function will pad the
     /// vector to the maximum number of public values.
     #[must_use]
@@ -149,8 +149,8 @@
     }
 }
 
-impl<F: AbstractField> From<PublicValues<u64, u64, u64>> for PublicValues<[F; 4], Word<F>, F> {
-    fn from(value: PublicValues<u64, u64, u64>) -> Self {
+impl<F: AbstractField> From<PublicValues<u64, u64, u32>> for PublicValues<[F; 4], Word<F>, F> {
+    fn from(value: PublicValues<u64, u64, u32>) -> Self {
         let PublicValues {
             committed_value_digest,
             deferred_proofs_digest,
@@ -184,26 +184,26 @@
         });
 
         let deferred_proofs_digest: [_; POSEIDON_NUM_WORDS] =
-            core::array::from_fn(|i| F::from_canonical_u64(deferred_proofs_digest[i]));
+            core::array::from_fn(|i| F::from_canonical_u32(deferred_proofs_digest[i]));
 
-        let pc_start_rel = F::from_canonical_u64(pc_start_rel);
-        let next_pc_rel = F::from_canonical_u64(next_pc_rel);
-        let exit_code = F::from_canonical_u64(exit_code);
-        let prev_exit_code = F::from_canonical_u64(prev_exit_code);
-        let shard = F::from_canonical_u64(shard);
-        let execution_shard = F::from_canonical_u64(execution_shard);
-        let next_execution_shard = F::from_canonical_u64(next_execution_shard);
+        let pc_start_rel = F::from_canonical_u32(pc_start_rel);
+        let next_pc_rel = F::from_canonical_u32(next_pc_rel);
+        let exit_code = F::from_canonical_u32(exit_code);
+        let prev_exit_code = F::from_canonical_u32(prev_exit_code);
+        let shard = F::from_canonical_u32(shard);
+        let execution_shard = F::from_canonical_u32(execution_shard);
+        let next_execution_shard = F::from_canonical_u32(next_execution_shard);
         let previous_init_addr_word = Word::from(previous_init_addr_word);
         let last_init_addr_word = Word::from(last_init_addr_word);
         let previous_finalize_addr_word = Word::from(previous_finalize_addr_word);
         let last_finalize_addr_word = Word::from(last_finalize_addr_word);
-        let last_timestamp = F::from_canonical_u64(last_timestamp);
-        let last_timestamp_inv = F::from_canonical_u64(last_timestamp_inv);
-        let global_init_count = F::from_canonical_u64(global_init_count);
-        let global_finalize_count = F::from_canonical_u64(global_finalize_count);
-        let global_count = F::from_canonical_u64(global_count);
+        let last_timestamp = F::from_canonical_u32(last_timestamp);
+        let last_timestamp_inv = F::from_canonical_u32(last_timestamp_inv);
+        let global_init_count = F::from_canonical_u32(global_init_count);
+        let global_finalize_count = F::from_canonical_u32(global_finalize_count);
+        let global_count = F::from_canonical_u32(global_count);
         let global_cumulative_sum =
-            SepticDigest(SepticCurve::convert(global_cumulative_sum.0, F::from_canonical_u64));
+            SepticDigest(SepticCurve::convert(global_cumulative_sum.0, F::from_canonical_u32));
 
         Self {
             committed_value_digest,
diff --git a/pv_t_u32_wip.diff b/pv_t_u32_wip.diff
new file mode 100644
index 0000000000..e69de29bb2
