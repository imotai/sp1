use std::path::{Path, PathBuf};
use std::{env, fs};

fn add_src_files(build: &mut cc::Build, dir: &Path) -> std::io::Result<()> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            // Recurse into subdirectories
            add_src_files(build, &path)?;

            // Add only .c, .cpp, or .cu files.
        } else if path.extension().and_then(|ext| ext.to_str()) == Some("c")
            || path.extension().and_then(|ext| ext.to_str()) == Some("cpp")
            || path.extension().and_then(|ext| ext.to_str()) == Some("cu")
        {
            build.file(path);
        }
    }
    Ok(())
}

fn builder() -> cc::Build {
    let mut build = cc::Build::new();

    // Compiler flags.
    build
        .cuda(true)
        .flag("-std=c++20")
        .flag("-default-stream=per-thread")
        .flag("-Xcompiler")
        .flag("-fopenmp")
        .flag("-lnvToolsExt")
        .flag("-arch=sm_89")
        .flag("-ldl")
        .flag("-lnvToolsExt")
        .flag("--expt-relaxed-constexpr");

    // Set the "-G" flag if the PROFILE_DEBUG_DATA environment variable is set to "true". This can
    // be set during kernel profilining.
    if let Some(profile_debug_data) = env::var_os("PROFILE_DEBUG_DATA") {
        if profile_debug_data == "true" {
            build.flag("-G");
        }
    }

    build
}

fn cbindgen_builder() -> cbindgen::Builder {
    /// The warning placed in the cbindgen header.
    const AUTOGEN_WARNING: &str =
        "/* Automatically generated by `cbindgen`. Not intended for manual editing. */";

    // Generate a header containing bindings to the crate.
    cbindgen::Builder::new()
        .with_pragma_once(true)
        .with_autogen_warning(AUTOGEN_WARNING)
        .with_no_includes()
        .with_sys_include("cstdint")
        .with_parse_deps(true)
        .with_parse_include(&[
            "sp1-stark",
            "sp1-primitives",
            "p3-baby-bear",
            "sp1-core-machine",
            "sp1-core-executor",
        ])
        .with_parse_extra_bindings(&[
            "sp1-stark",
            "sp1-primitives",
            "p3-baby-bear",
            // TODO(tqn) I think this pulls in all the extern fns from this crate, which is undesirable.
            "sp1-core-machine",
        ])
        .rename_item("BabyBear", "BabyBearP3")
        // .include_item("MemoryRecord") // Just for convenience. Not exposed, so we need to manually do this.
        // .include_item("SyscallCode") // Required for populating the CPU columns for ECALL.
        // .include_item("SepticExtension")
        // .include_item("SepticCurve")
        // .include_item("MemoryLocalCols")
        // .include_item("MEMORY_LOCAL_INITIAL_DIGEST_POS")
        // .include_item("Ghost")
        // .include_item("MemoryInitCols")
        // .include_item("MemoryInitializeFinalizeEvent")
        // .include_item("GlobalInteractionOperation")
        .include_item("GlobalInteractionEvent")
        // .include_item("Poseidon2StateCols")
        .include_item("GlobalCols")
        // .include_item("INTERACTION_KIND_GLOBAL")
        .with_namespace("csl_sys")
        .with_crate(env::var("CARGO_MANIFEST_DIR").unwrap())
}

/// Place a relative symlink pointing to `original` at `link`.
fn rel_symlink_file<P, Q>(original: P, link: Q)
where
    P: AsRef<Path>,
    Q: AsRef<Path>,
{
    #[cfg(unix)]
    use std::os::unix::fs::symlink;
    #[cfg(windows)]
    use std::os::windows::fs::symlink_file as symlink;

    let target_dir = link.as_ref().parent().unwrap();
    fs::create_dir_all(target_dir).unwrap();
    let _ = fs::remove_file(&link);
    let relpath = pathdiff::diff_paths(original, target_dir).unwrap();
    symlink(relpath, link).unwrap();
}

fn main() {
    println!("cargo:rerun-if-changed=../../cuda/");
    println!("cargo:rerun-if-changed=../../sppark/");

    let nvcc = which::which("nvcc").expect("nvcc not found");

    let cuda_version =
        std::process::Command::new(nvcc).arg("--version").output().expect("failed to get version");
    if !cuda_version.status.success() {
        panic!("{:?}", cuda_version);
    }
    let cuda_version = String::from_utf8(cuda_version.stdout).unwrap();
    let x =
        cuda_version.find("release ").expect("can't find \"release X.Y,\" in --version output") + 8;
    let y = cuda_version[x..].find(',').expect("can't parse \"release X.Y,\" in --version output");
    let v = cuda_version[x..x + y].parse::<f32>().unwrap();
    if v < 12.0 {
        panic!("Unsupported CUDA version {} < 12.0", v);
    }

    // The crate directory.
    let crate_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let src_dir = crate_dir.join("../../cuda/");
    // Get a new builder with the correct flags.
    let mut build = builder();

    env::set_var("DEP_SPPARK_ROOT", "../../sppark/");
    if let Some(include) = env::var_os("DEP_SPPARK_ROOT") {
        let include = crate_dir.join(include);
        build.include(include);
        build.define("SPPARK", None);
        build.define("FEATURE_BABY_BEAR", None);
        build.file("../../sppark/rust/src/lib.cpp").file("../../sppark/util/all_gpus.cpp");
    }

    // let sppark_dir = crate_dir.join("../../sppark/");
    // // Add all the source files.
    // add_src_files(&mut build, &sppark_dir).expect("Failed to find c, cpp, or cu files");
    // // Add all header files.
    // add_include_directories(&mut build, &sppark_dir).expect("Failed to find h, hpp, or cuh files");
    // build.define("SPPARK", None);
    // build.define("FEATURE_BABY_BEAR", None);

    // Add all the source files.
    add_src_files(&mut build, &src_dir).expect("Failed to find c, cpp, or cu files");
    // Add all header files.
    build.include(&src_dir);

    // TODO(tqn) comments
    // The name of all include directories involved, used to find and output header files.
    const INCLUDE_DIRNAME: &str = "include";
    // The output directory, where built artifacts should be placed.
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    // The directory to place headers into.
    let out_include_dir = out_dir.join(INCLUDE_DIRNAME);
    let cbindgen_hpp = "csl-cbindgen.hpp";
    match cbindgen_builder().generate() {
        Ok(bindings) => {
            let header_path = out_include_dir.join(cbindgen_hpp);
            // Write the bindings to the target include directory.
            fs::create_dir_all(&out_include_dir).unwrap();
            if bindings.write_to_file(&header_path) {
                // TODO(tqn) disable when not developing
                // The target directory that the cargo invocation is using.
                // Headers are symlinked into `target/include` purely for IDE purposes.
                {
                    let mut dir = out_dir.clone();
                    loop {
                        if dir.ends_with("target") {
                            // Symlink the header to the fixed include directory.
                            rel_symlink_file(
                                header_path,
                                dir.join(INCLUDE_DIRNAME).join(cbindgen_hpp),
                            );
                            break;
                        }
                        if !dir.pop() {
                            break;
                        }
                    }
                }
            }
        }
        Err(cbindgen::Error::ParseSyntaxError { .. }) => {} // Ignore parse errors so rust-analyzer can run.
        Err(e) => panic!("{:?}", e),
    }
    build.include(out_include_dir);

    // let sppark_dir = crate_dir.join("../../sppark/");
    // // Add all the source files.
    // add_src_files(&mut build, &sppark_dir).expect("Failed to find c, cpp, or cu files");
    // // Add all header files.
    // add_include_directories(&mut build, &sppark_dir).expect("Failed to find h, hpp, or cuh files");
    // build.define("SPPARK", None);
    // build.define("FEATURE_BABY_BEAR", None);

    // Compile the library.
    build.compile("sys-cuda");
}
