use std::path::PathBuf;
use std::{env, fs};

fn cbindgen_builder() -> cbindgen::Builder {
    /// The warning placed in the cbindgen header.
    const AUTOGEN_WARNING: &str =
        "/* Automatically generated by `cbindgen`. Not intended for manual editing. */";

    // Generate a header containing bindings to the crate.
    cbindgen::Builder::new()
        .with_pragma_once(true)
        .with_autogen_warning(AUTOGEN_WARNING)
        .with_no_includes()
        .with_sys_include("cstdint")
        .with_parse_deps(true)
        .with_parse_include(&[
            "sp1-hypercube",
            "sp1-primitives",
            "p3-koala-bear",
            "sp1-core-machine",
            "slop-koala-bear",
            "sp1-core-executor",
            "sp1-recursion-executor",
            "sp1-recursion-machine",
        ])
        .with_parse_extra_bindings(&[
            "sp1-hypercube",
            "sp1-primitives",
            "p3-koala-bear",
            "slop-koala-bear",
            // TODO(tqn) I think this pulls in all the extern fns from this crate, which is undesirable.
            "sp1-recursion-executor",
            "sp1-recursion-machine",
            "sp1-core-machine",
        ])
        .rename_item("KoalaBear", "KoalaBearP3")
        // .include_item("MemoryRecord") // Just for convenience. Not exposed, so we need to manually do this.
        // .include_item("SyscallCode") // Required for populating the CPU columns for ECALL.
        // .include_item("SepticExtension")
        // .include_item("SepticCurve")
        // .include_item("MemoryLocalCols")
        // .include_item("MEMORY_LOCAL_INITIAL_DIGEST_POS")
        // .include_item("Ghost")
        // .include_item("MemoryInitCols")
        // .include_item("MemoryInitializeFinalizeEvent")
        // .include_item("GlobalInteractionOperation")
        .include_item("GlobalInteractionEvent")
        .include_item("GlobalCols")
        .include_item("MemoryAccessColsChips")
        .include_item("Poseidon2Instr")
        .include_item("Poseidon2PreprocessedColsWide")
        .include_item("Poseidon2Event")
        .include_item("SelectInstr")
        .include_item("SelectPreprocessedCols")
        .include_item("SelectEvent")
        .include_item("SelectCols")
        .include_item("BaseAluInstr")
        .include_item("BaseAluAccessCols")
        .include_item("BaseAluEvent")
        .include_item("BaseAluValueCols")
        .include_item("ExtAluInstr")
        .include_item("ExtAluAccessCols")
        .include_item("ExtAluEvent")
        .include_item("ExtAluValueCols")
        .include_item("ExtFeltInstr")
        .include_item("ExtFeltEvent")
        .include_item("ConvertAccessCols")
        .include_item("ConvertValueCols")
        .include_item("Poseidon2LinearLayerAccessCols")
        .include_item("Poseidon2LinearLayerValueCols")
        .include_item("Poseidon2LinearLayerInstr")
        .include_item("Poseidon2SBoxInstr")
        .include_item("Poseidon2SBoxIo")
        .include_item("Poseidon2SBoxAccessCols")
        .include_item("Poseidon2SBoxValueCols")
        .include_item("NUM_CONVERT_ENTRIES_PER_ROW")
        .include_item("NUM_LINEAR_ENTRIES_PER_ROW")
        .include_item("NUM_SBOX_ENTRIES_PER_ROW")
        .include_item("PERMUTATION_WIDTH")
        .include_item("PrefixSumChecksEvent")
        .include_item("PrefixSumChecksCols")
        // .include_item("Poseidon2StateCols")
        // .include_item("INTERACTION_KIND_GLOBAL")
        .with_namespace("csl_sys")
        .with_crate(env::var("CARGO_MANIFEST_DIR").unwrap())
}

/// Place a relative symlink pointing to `original` at `link`.
fn rel_symlink_file<P, Q>(original: P, link: Q)
where
    P: AsRef<std::path::Path>,
    Q: AsRef<std::path::Path>,
{
    #[cfg(unix)]
    use std::os::unix::fs::symlink;
    #[cfg(windows)]
    use std::os::windows::fs::symlink_file as symlink;

    let target_dir = link.as_ref().parent().unwrap();
    fs::create_dir_all(target_dir).unwrap();
    let _ = fs::remove_file(&link);
    let relpath = pathdiff::diff_paths(original, target_dir).unwrap();
    symlink(relpath, link).unwrap();
}

fn main() {
    // Directives for tracking changes in folders
    println!("cargo:rerun-if-changed=../../cuda/");
    println!("cargo:rerun-if-changed=../../sppark/");
    println!("cargo:rerun-if-changed=../../Makefile");
    println!("cargo:rerun-if-changed=CMakeLists.txt");
    // Directives for tracking changes in compilation profiles
    println!("cargo:rerun-if-env-changed=PROFILE");
    println!("cargo:rerun-if-env-changed=OPT_LEVEL");
    println!("cargo:rerun-if-env-changed=DEBUG");

    // Check for nvcc
    let nvcc = which::which("nvcc").expect("nvcc not found");

    // Get CUDA version
    let cuda_version =
        std::process::Command::new(nvcc).arg("--version").output().expect("failed to get version");
    if !cuda_version.status.success() {
        panic!("{cuda_version:?}");
    }
    let cuda_version = String::from_utf8(cuda_version.stdout).unwrap();
    let x =
        cuda_version.find("release ").expect("can't find \"release X.Y,\" in --version output") + 8;
    let y = cuda_version[x..].find(',').expect("can't parse \"release X.Y,\" in --version output");
    let v = cuda_version[x..x + y].parse::<f32>().unwrap();
    if v < 12.0 {
        panic!("Unsupported CUDA version {v} < 12.0");
    }

    // The crate directory.
    let crate_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());

    // The output directory, where built artifacts should be placed.
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // The directory to place headers into.
    let out_include_dir = out_dir.join("include");
    const INCLUDE_DIRNAME: &str = "include";

    // Generate cbindgen headers BEFORE building with CMake
    let cbindgen_hpp = "csl-cbindgen.hpp";
    let header_path = out_include_dir.join(cbindgen_hpp);

    match cbindgen_builder().generate() {
        Ok(bindings) => {
            // Write the bindings to the target include directory.
            fs::create_dir_all(&out_include_dir).unwrap();
            if bindings.write_to_file(&header_path) {
                // TODO(tqn) disable when not developing
                // The target directory that the cargo invocation is using.
                // Headers are symlinked into `target/include` purely for IDE purposes.
                {
                    let mut dir = out_dir.clone();
                    loop {
                        if dir.ends_with("target") {
                            // Symlink the header to the fixed include directory.
                            rel_symlink_file(
                                &header_path,
                                dir.join(INCLUDE_DIRNAME).join(cbindgen_hpp),
                            );
                            break;
                        }
                        if !dir.pop() {
                            break;
                        }
                    }
                }
            }
        }
        Err(cbindgen::Error::ParseSyntaxError { .. }) => {
            // Ignore parse errors in the build script.
            // We let rust-analyzer/rustc run to report the syntax error with diagnostics.
            return;
        }
        Err(e) => panic!("{e:?}"),
    }

    // Determine architectures
    let cuda_archs = env::var("CUDA_ARCHS").unwrap_or_else(|_| {
        if v < 12.8 {
            "80,86,89".to_string()
        } else {
            "80,86,89,90,100,120".to_string()
        }
    });

    // Set up sppark environment
    env::set_var("DEP_SPPARK_ROOT", "../../sppark/");

    // Build using CMake
    let mut cmake_config = cmake::Config::new(".");

    // Pass CUDA configuration to CMake
    cmake_config
        .define("CUDA_ARCHS", &cuda_archs)
        .define("CUDA_VERSION", format!("{v}"))
        .define("CBINDGEN_INCLUDE_DIR", out_include_dir.display().to_string());

    // Pass profile debug flag if set
    if let Some(profile_debug_data) = env::var_os("PROFILE_DEBUG_DATA") {
        if profile_debug_data == "true" {
            cmake_config.define("PROFILE_DEBUG_DATA", "true");
        }
    }

    // Determine build type based on profile
    let profile = env::var("PROFILE").unwrap_or_else(|_| "release".to_string());
    if profile == "debug" {
        cmake_config.profile("Debug");
    } else {
        cmake_config.profile("Release");
    }

    // Build via CMake
    let _dst = cmake_config.build();

    // Link the library
    println!("cargo:rustc-link-search=native={}/../../target/cuda-build/lib", crate_dir.display());
    println!("cargo:rustc-link-lib=static=sys-cuda");

    // Add CUDA library search paths
    if let Ok(cuda_path) = env::var("CUDA_PATH") {
        println!("cargo:rustc-link-search=native={cuda_path}/lib64");
        println!("cargo:rustc-link-search=native={cuda_path}/lib");
    } else {
        // Try common CUDA installation paths
        for cuda_version in
            &["12.9", "12.8", "12.7", "12.6", "12.5", "12.4", "12.3", "12.2", "12.1", "12.0"]
        {
            let cuda_lib = format!("/usr/local/cuda-{cuda_version}/targets/x86_64-linux/lib");
            if std::path::Path::new(&cuda_lib).exists() {
                println!("cargo:rustc-link-search=native={cuda_lib}");
                break;
            }
        }
        // Also try the generic path
        println!("cargo:rustc-link-search=native=/usr/local/cuda/lib64");
    }

    // Link CUDA runtime libraries
    println!("cargo:rustc-link-lib=cudart");
    println!("cargo:rustc-link-lib=cudadevrt");

    // Link system libraries
    println!("cargo:rustc-link-lib=stdc++");
    println!("cargo:rustc-link-lib=gomp");
    println!("cargo:rustc-link-lib=dl");

    // Add include directories for compilation if needed
    println!("cargo:include={}", out_include_dir.display());
}
