// TODO: After finalizing vkeys, decide on a vkey verification solution. Then, clean up the
// constants and error enum in this file and update sp1_prover::tests::sp1_verifier_valid.

use alloc::boxed::Box;

use sp1_hypercube::{MachineVerifierConfigError, SP1RecursionProof};
use thiserror::Error;

// NOTE: that all these constants and types are checked by sp1_prover::tests::sp1_verifier_valid.
// If you add a new proof, you MUST add to the test in that crate.

pub mod internal;

use self::internal::*;

/// A reason why the verifier rejects a given proof.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum CompressedError {
    #[error("failed to deserialize proof: {0}")]
    DeserializeProof(Box<bincode::ErrorKind>),
    #[error("failed to deserialize vkey hash: {0}")]
    DeserializeVkeyHash(Box<bincode::ErrorKind>),
    #[error("failed to verify proof: {0}")]
    ProofRejected(#[from] MachineVerifierConfigError<GC, C>),
    // #[error("single-shard proofs are currently unsupported by this verifier")]
    // SingleShard,
    #[error("given public values do not match the commitment in the proof")]
    PublicValuesMismatch,
}

/// A verifier for SP1 "compressed" proofs.
#[derive(Debug)]
pub struct CompressedVerifier;
impl CompressedVerifier {
    /// Attempts to verify an SP1 "compressed" proof, as generated by the SP1 SDK.
    /// Returns `Ok` if the proof verifies or `Err` with the reason that verification failed.
    ///
    /// Due to technical limitations, this verifier rejects single-shard proofs, which roughly means
    /// proofs that come from very short programs. In this case, the verifier returns
    /// `Err(CompressedError::SingleShard)`.
    ///
    /// # Arguments
    ///
    /// * `proof` - The proof bytes.
    /// * `sp1_vkey_hash` - The SP1 vkey hash.
    ///
    /// The arguments may be generated in the following manner:
    ///
    /// ```ignore
    /// use sp1_sdk::{HashableKey, ProverClient, SP1Proof};
    /// let client = ProverClient::builder().cpu().build();
    /// let (pk, vk) = client.setup(ELF);
    /// let sp1_vkey_hash = bincode::serialize(&vk.hash_babybear()).unwrap();
    /// let proof = match client.prove(&pk, &stdin).compressed().run().unwrap().proof {
    ///     SP1Proof::Compressed(proof) => bincode::serialize(&proof),
    ///     _ => unreachable!("expected compressed proof"),
    /// };
    /// ```
    pub fn verify(
        proof: &[u8],
        sp1_public_inputs: &[u8],
        sp1_vkey_hash: &[u8],
    ) -> Result<(), CompressedError> {
        let recursion_proof: Box<SP1RecursionProof<GC, C>> =
            bincode::deserialize(proof).map_err(CompressedError::DeserializeProof)?;
        let vkey_hash: [F; 8] =
            bincode::deserialize(sp1_vkey_hash).map_err(CompressedError::DeserializeVkeyHash)?;

        verify_compressed(&recursion_proof, sp1_public_inputs, &vkey_hash)?;

        Ok(())
    }
}
